# Strings | Output-Based Interview Questions

---

## Question 1: String literal vs == vs equals()

### Code
```java
String s1 = "Java";
String s2 = "Java";

System.out.println(s1 == s2);
System.out.println(s1.equals(s2));

```

Output:
true
true

ðŸ§  **Explanation:**

- "Java" is a string literal
- Java stores string literals in the String Constant Pool
- Since both s1 and s2 have the same value "Java", only one object is created
- Both variables point to the same memory location

**So:**
- `s1 == s2` â†’ true (same reference)
- `s1.equals(s2)` â†’ true (same value)

ðŸ‘‰ **Interview takeaway:**
- String literals save memory because Java reuses objects from the String pool

---

## Question 2: new String() vs == and .equals()
	
### Code
```java
public class Test {
    public static void main(String[] args) {
        String s1 = new String("Java");
        String s2 = new String("Java");

        System.out.println(s1 == s2);
        System.out.println(s1.equals(s2));
    }
}

```

### ðŸ§  Explanation

- `new String("Java")` creates a **new object in heap memory every time**
- So `s1` and `s2` point to **different memory locations**
- `==` compares **references**, not values â†’ returns `false`
- `.equals()` compares **content**, and both values are `"Java"` â†’ returns `true`

### ðŸ‘‰ Interview takeaway

- `==` â†’ reference comparison  
- `.equals()` â†’ value comparison  
- `new String()` does **not** use String Constant Pool  
- Prefer **string literals** for memory efficiency


# 16 jan 2026 
# String Concatenation â€“ SCP vs Heap (Golden Rules)
---

## RULE 1 â€“ Literal + Literal â†’ Compile Time â†’ SCP

```java
String a = "Hello";
String b = "Hel" + "lo";

System.out.println(a == b);   // true
```

**Why**
- Both sides are pure string literals  
- Compiler joins them at compile time  
- Only ONE object created in String Constant Pool  
- == compares reference â†’ same reference â†’ true

---

## RULE 2 â€“ Variable + Anything â†’ Runtime â†’ Heap

```java
String x = "Hel";
String y = x + "lo";

System.out.println("Hello" == y);   // false
```

**Why**
- x is a variable â†’ concat happens at runtime  
- Runtime concat creates NEW object in heap  
- Reference of y â‰  reference of "Hello" in SCP  
- == compares reference â†’ false

---

## RULE 3 â€“ final Variable + Literal â†’ Compile Time â†’ SCP

```java
final String p = "Hel";
String q = p + "lo";

System.out.println("Hello" == q);   // true
```

**Why**
- final variable is treated as constant by compiler  
- Compiler optimizes as: "Hel" + "lo"  
- Becomes compile-time concatenation â†’ SCP  
- Same reference â†’ == returns true

---

## MEMORY FORMULA (Remember This)

- literal + literal â†’ SCP â†’ true with ==
- variable + anything â†’ HEAP â†’ false with ==
- final variable + literal â†’ SCP â†’ true with ==


---

# Day 4 â€“ Reference, Immutability & Real Logic

## 1. String Immutability Trap

```java
String a = "hello";
a.toUpperCase();
System.out.println(a);
```

**Output**
- hello

**Explanation**
- String is immutable  
- toUpperCase() creates a new object  
- Since result is not reassigned, original string remains unchanged

---

## 2. StringBuilder is Mutable

```java
StringBuilder sb = new StringBuilder("hi");
sb.append("bye");
System.out.println(sb);
```

**Output**
- hibye

**Explanation**
- StringBuilder modifies the same object  
- No new object is created  
- Changes happen in place (mutable behavior)

---

## 3. Primitive vs Reference

```java
int x = 5;
int y = x;
y = 10;
System.out.println(x);
```

**Output**
- 5

**Explanation**
- Primitive types copy value, not reference  
- Changing y does not affect x

---

## 4. Reference Sharing Trap

```java
List<Integer> data = new ArrayList<>();
data.add(1);
data.add(2);

List<Integer> backup = data;
backup.add(3);

System.out.println(data);
```

**Output**
- [1, 2, 3]

**Explanation**
- backup = data creates another reference to same object  
- No new list created  
- Modification via backup affects data

---

## 5. Independent Copy â€“ Correct Way

```java
List<Integer> data = new ArrayList<>();
data.add(1);
data.add(2);

List<Integer> backup = new ArrayList<>(data);
backup.add(3);

System.out.println(data);
System.out.println(backup);
```

**Output**
- [1, 2]  
- [1, 2, 3]

**Explanation**
- new ArrayList<>(data) creates a new object  
- Values are copied, not the reference  
- Changes in backup do not affect data

---

## Key Takeaways

- No `new` keyword â†’ same object, only new reference  
- String is immutable, StringBuilder is mutable  
- Primitive types copy values, objects copy references  
- Use `new ArrayList<>(oldList)` for independent copy
