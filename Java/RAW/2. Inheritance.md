# **Inheritance**

---

## **Q1. What is inheritance and why do Page classes extend BaseClass?**

**Answer:**
Inheritance allows one class to reuse the variables and methods of another class.  
In my framework, I create a BaseClass that contains WebDriver setup and common utilities like `openUrl()` and waits.  
Page classes extend BaseClass so they inherit driver and reusable methods without rewriting them, which keeps the framework clean and maintainable.

---

## **Q2. Can private variables be inherited? Why?**

**Answer:**
No. Private variables cannot be inherited because their access is limited to the same class only.  
Even if a class extends the parent, private members stay hidden.  
That‚Äôs why private locators in POM are only accessible inside the same page class.

---

## **Q3. What keyword is used for inheritance?**

**Answer:**
The keyword used is **extends**.  
One class extends another class to reuse its methods and variables.

---

## **Q4. Why is WebDriver usually protected in the BaseClass?**

**Answer:**
If we make it private, Page classes can‚Äôt access it.  
If we make it public, anyone can modify it ‚Äî which is unsafe.  
So protected gives the right balance between accessibility and security.

---

## **Q5. Can constructors be inherited?**

**Answer:**
No, constructors cannot be inherited.  
They belong to the specific class and are used only to initialize that class‚Äôs objects.

---

# **Sample Inheritance Code Example (Interview Demo)**

```java
class BaseClass {
    WebDriver driver;

    void openUrl(String url) {
        driver.get(url);
    }
}

class LoginPage extends BaseClass {

    void login() {
        // using driver inherited from BaseClass
        System.out.println("Login using inherited driver");
    }
}
```
---

**Explanation to Speak in Interview:**
BaseClass contains driver setup and common methods.  
LoginPage extends BaseClass and directly reuses driver and utilities ‚Äî this is inheritance in my automation framework.

---
# üìå Inheritance ‚Äì Interview Notes 

---

## Q1. Can a child class inherit private variables?

No. Private variables are **NOT inherited** because they are accessible only within the same class.

---

## Q2. Difference between protected and private in inheritance?

üëâ **private** ‚Üí accessible only within the same class  
üëâ **protected** ‚Üí accessible in the same package and in child classes outside the package

---

## Q3. Parent has only parameterized constructor & child does not call super()?

**Compile-time error.**

Yes, it will be a compile-time error because Java tries to call `super()` implicitly, but the parent does not have a default constructor.  
If the parent has only a parameterized constructor, then the child **must** call it explicitly, whether you ‚Äúneed‚Äù it or not.

---

## Q4. Why does Java force child to call parent‚Äôs parameterized constructor?

Java forces this to ensure the **parent part of the object is properly initialized** before the child object is created.

---

## Q5. Parent has BOTH default + parameterized constructor, child doesn‚Äôt call super()

If `super()` is not written, Java always calls the **parent‚Äôs default constructor**.

---

## Q6. Can a child class override static methods?

No. Static methods belong to the **class**, not the object, so they cannot be overridden.  
What actually happens is **method hiding**, not overriding.

---

## Q7. Can a child class override a final method?

No. A final method cannot be overridden because final means the implementation is locked and cannot be changed by child classes.

---

## Q8. Can a child reduce access level while overriding?

No. A child class cannot reduce the access level while overriding because it would break polymorphism.  
Access level can be the same or more permissive, not more restrictive.

---

## Q9. Parent method throws Exception, child method overrides it  
Can the child throw:
- a broader exception?
- a narrower exception?
- no exception?

**Answer ‚Äì While overriding a method:**

‚ùå Child method **CANNOT** throw a broader checked exception than the parent  
‚úÖ Child method **CAN** throw:
- the same exception  
- a narrower exception  
- no exception at all  

---

## Notes ‚Äì Exception Hierarchy

```java
Exception
‚îî‚îÄ‚îÄ IOException
‚îî‚îÄ‚îÄ FileNotFoundException

- Exception ‚Üí broader  
- IOException ‚Üí narrower  
- FileNotFoundException ‚Üí more narrow

```

So:
- **Broader exception** = higher in hierarchy  
- **Narrower exception** = child of that exception  

---

## Q10. Which of these is valid?

- Parent p = new Child();
- Child c = new Parent();

**Correct answer:**

- ‚úÖ `Parent p = new Child();` ‚Üí VALID (polymorphism)  
- ‚ùå `Child c = new Parent();` ‚Üí INVALID  

Parent doesn‚Äôt have child-specific behavior, so child reference cannot point to parent object.

---

## Q11. Why do Page classes extend Base class in automation framework?

Base class contains WebDriver setup and reusable methods.  
Page classes extend it to **avoid duplication** and **reuse code**.

---

## Q12. Is WebDriver usually declared protected in a base class?

Yes. WebDriver is usually declared **protected** so that child page classes can access it while still preventing unrestricted access.

---

# üìå Inheritance ‚Äì Interview Notes (Product-Based | SDET 4+ Years)

---

## Q1. Why do we use `super` keyword in inheritance?

**Answer:**  
We use the `super` keyword to refer to the **parent class**.  
It is mainly used when the child class wants to access:
- parent class constructor
- parent class variables
- parent class methods

In short, `super` helps the child class explicitly use the parent‚Äôs version.

---

## Q2. Difference between `this` and `super`

**Answer:**  
- `this` refers to the **current class object**
- `super` refers to the **parent class object**

`this` is used to access current class members,  
`super` is used to access parent class members.

---

## Q3. Do we need to use `super` in a constructor?

**Answer:**  
Yes, we use `super()` when the child class wants to call the **parent class constructor**.

- If we don‚Äôt write `super()` explicitly, Java inserts it automatically **only if the parent has a default constructor**.
- If the parent has **only a parameterized constructor**, then the child **must explicitly call `super(args)`**, otherwise compilation fails.

---

## Q4. When do we use `super.method()`?

**Answer:**  
We use `super.method()` when:
- the child class has overridden a method
- but still wants to call the **parent version** of that method

This is useful when we want **partial reuse + customization**.

---

## Q5. Can we use `super` to access parent variables?

**Answer:**  
Yes.  
`super.variableName` is used when:
- parent and child both have variables with the same name
- and we want to clearly refer to the parent‚Äôs variable

---

## Q6. In automation framework, where is `super` used?

**Answer:**  
In automation frameworks, `super` is commonly used during:
- **WebDriver initialization**
- calling parent constructor from Base class
- accessing reusable setup logic defined in the Base class

Example use case: calling Base class constructor from Test or Page class.

---

## Q7. If a child overrides a method, can it still call the parent version?

**Answer:**  
Yes.  
Even after overriding, the child can still call the parent version using `super.method()`.

This is the **main reason `super` exists** ‚Äî to allow access to parent behavior even after overriding.

---

## Q8. What happens if you don‚Äôt write `super()` explicitly in child constructor?

**Answer:**  
- Java automatically inserts `super()` **only if parent has a default constructor**
- If parent has **only a parameterized constructor**, and child does not call it explicitly:
  üëâ **Compile-time error**

Because Java forces proper initialization of the parent part of the object.

---

## üîë One-Line Interview Summary

`super` is used to access parent class constructor, methods, or variables ‚Äî especially when the child overrides behavior but still needs parent logic.

---
## Q1. If parent reference points to child object

```java
Parent p = new Child();
```
---
Which methods are called at runtime ‚Äî parent or child?
On what basis does Java decide this?

Answer:
Java uses runtime polymorphism for method calls.
The actual object (Child) decides which method runs, not the reference type.

---

## Q2. Which members are decided at compile time and which at runtime?
	‚Ä¢	Methods ‚Üí runtime (dynamic binding)
	‚Ä¢	Variables ‚Üí compile time (based on reference type)
---

## Q3. Can variables be overridden like methods in Java? If not, what actually happens?

Answer:
Variables are not overridden.
If parent and child have the same variable name, the variable accessed depends on the reference type, not the object.

```java
class Parent {
    int x = 10;

    void show() {
        System.out.println("Parent show()");
    }
}

class Child extends Parent {
    int x = 20;

    void show() {
        System.out.println("Child show()");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();

        System.out.println(p.x);
        p.show();
    }
}
```

---

## Output.
10
Child show()

---
‚Ä¢	Parent p = new Child();
‚Üí Reference type is Parent
‚Üí Object created is Child
	‚Ä¢	System.out.println(p.x);
‚Üí x is a variable
‚Üí Variables are decided at compile time
‚Üí Compiler checks reference type (Parent)
‚Üí Prints Parent.x ‚Üí 10
	‚Ä¢	p.show();
‚Üí show() is a method
‚Üí Methods are decided at runtime
‚Üí JVM checks actual object (Child)
‚Üí Calls Child.show() ‚Üí ‚ÄúChild show()‚Äù
---

## Q4. Why is Parent p = new Child() heavily used in automation frameworks?

(Framework-design question)

Answer:
Because it allows loose coupling and flexibility.

Real automation reason:
	‚Ä¢	Framework code depends on parent type, not concrete child
	‚Ä¢	Makes it easy to:
	‚Ä¢	switch implementations
	‚Ä¢	reuse code
	‚Ä¢	write generic utilities

	WebDriver driver = new ChromeDriver();
	
	We use WebDriver reference so we can switch browsers (Chrome, Firefox, Edge) without changing test code.

