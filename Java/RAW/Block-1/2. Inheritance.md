# **Inheritance**

---

## **Q1. What is inheritance and why do Page classes extend BaseClass?**

**Answer:**
Inheritance allows one class to reuse the variables and methods of another class.  
In my framework, I create a BaseClass that contains WebDriver setup and common utilities like `openUrl()` and waits.  
Page classes extend BaseClass so they inherit driver and reusable methods without rewriting them, which keeps the framework clean and maintainable.

---

## **Q2. Can private variables be inherited? Why?**

**Answer:**
No. Private variables cannot be inherited because their access is limited to the same class only.  
Even if a class extends the parent, private members stay hidden.  
Thatâ€™s why private locators in POM are only accessible inside the same page class.

---

## **Q3. What keyword is used for inheritance?**

**Answer:**
The keyword used is **extends**.  
One class extends another class to reuse its methods and variables.

---

## **Q4. Why is WebDriver usually protected in the BaseClass?**

**Answer:**
If we make it private, Page classes canâ€™t access it.  
If we make it public, anyone can modify it â€” which is unsafe.  
So protected gives the right balance between accessibility and security.

---

## **Q5. Can constructors be inherited?**

**Answer:**
No, constructors cannot be inherited.  
They belong to the specific class and are used only to initialize that classâ€™s objects.

> If Parent class has a constructor,
> Child class does NOT automatically get that constructor as its own.

---

# **Sample Inheritance Code Example (Interview Demo)**

```java
class BaseClass {
    WebDriver driver;

    void openUrl(String url) {
        driver.get(url);
    }
}

class LoginPage extends BaseClass {

    void login() {
        // using driver inherited from BaseClass
        System.out.println("Login using inherited driver");
    }
}
```
---

**Explanation to Speak in Interview:**
BaseClass contains driver setup and common methods.  
LoginPage extends BaseClass and directly reuses driver and utilities â€” this is inheritance in my automation framework.

---
# ğŸ“Œ Inheritance â€“ Interview Notes 

---

## Q1. Can a child class inherit private variables?

No. Private variables are **NOT inherited** because they are accessible only within the same class.

---

## Q2. Difference between protected and private in inheritance?

ğŸ‘‰ **private** â†’ accessible only within the same class  
ğŸ‘‰ **protected** â†’ accessible in the same package and in child classes outside the package

---

## Q3. Parent has only parameterized constructor & child does not call super()?

**Compile-time error.**

Yes, it will be a compile-time error because Java tries to call `super()` implicitly, but the parent does not have a default constructor.  
If the parent has only a parameterized constructor, then the child **must** call it explicitly, whether you â€œneedâ€ it or not.

---

## Q4. Why does Java force child to call parentâ€™s parameterized constructor?

Java forces this to ensure the **parent part of the object is properly initialized** before the child object is created.

---

## Q5. Parent has BOTH default + parameterized constructor, child doesnâ€™t call super()

If `super()` is not written, Java always calls the **parentâ€™s default constructor**.

---

## Q6. Can a child class override static methods?

No. Static methods belong to the **class**, not the object, so they cannot be overridden.  
What actually happens is **method hiding**, not overriding.

---

## Q7. Can a child class override a final method?

No. A final method cannot be overridden because final means the implementation is locked and cannot be changed by child classes.

---

## Q8. Can a child reduce access level while overriding?

No. A child class cannot reduce the access level while overriding because it would break polymorphism.  
Access level can be the same or more permissive, not more restrictive.

---

## Q9. Parent method throws Exception, child method overrides it  
Can the child throw:
- a broader exception?
- a narrower exception?
- no exception?

**Answer â€“ While overriding a method:**

âŒ Child method **CANNOT** throw a broader checked exception than the parent  
âœ… Child method **CAN** throw:
- the same exception  
- a narrower exception  
- no exception at all  

---

## Notes â€“ Exception Hierarchy

```java
Exception
â””â”€â”€ IOException
â””â”€â”€ FileNotFoundException

- Exception â†’ broader  
- IOException â†’ narrower  
- FileNotFoundException â†’ more narrow

```

So:
- **Broader exception** = higher in hierarchy  
- **Narrower exception** = child of that exception  

---

## Q10. Which of these is valid?

- Parent p = new Child();
- Child c = new Parent();

**Correct answer:**

- âœ… `Parent p = new Child();` â†’ VALID (polymorphism)  
- âŒ `Child c = new Parent();` â†’ INVALID  

Parent doesnâ€™t have child-specific behavior, so child reference cannot point to parent object.

---

## Q11. Why do Page classes extend Base class in automation framework?

Base class contains WebDriver setup and reusable methods.  
Page classes extend it to **avoid duplication** and **reuse code**.

---

## Q12. Is WebDriver usually declared protected in a base class?

Yes. WebDriver is usually declared **protected** so that child page classes can access it while still preventing unrestricted access.

---

# ğŸ“Œ Inheritance â€“  Notes

---

## Q1. Why do we use `super` keyword in inheritance?

**Answer:**  
We use the `super` keyword to refer to the **parent class**.  
It is mainly used when the child class wants to access:
- parent class constructor
- parent class variables
- parent class methods

In short, `super` helps the child class explicitly use the parentâ€™s version.

---

## Q2. Difference between `this` and `super`

**Answer:**  
- `this` refers to the **current class object**
- `super` refers to the **parent class object**

`this` is used to access current class members,  
`super` is used to access parent class members.

---

## Q3. Do we need to use `super` in a constructor?

**Answer:**  
Yes, we use `super()` when the child class wants to call the **parent class constructor**.

- If we donâ€™t write `super()` explicitly, Java inserts it automatically **only if the parent has a default constructor**.
- If the parent has **only a parameterized constructor**, then the child **must explicitly call `super(args)`**, otherwise compilation fails.

---

## Q4. When do we use `super.method()`?

**Answer:**  
We use `super.method()` when:
- the child class has overridden a method
- but still wants to call the **parent version** of that method

This is useful when we want **partial reuse + customization**.

---

## Q5. Can we use `super` to access parent variables?

**Answer:**  
Yes.  
`super.variableName` is used when:
- parent and child both have variables with the same name
- and we want to clearly refer to the parentâ€™s variable

---

## Q6. In automation framework, where is `super` used?

**Answer:**  
In automation frameworks, `super` is commonly used during:
- **WebDriver initialization**
- calling parent constructor from Base class
- accessing reusable setup logic defined in the Base class

Example use case: calling Base class constructor from Test or Page class.

---

## Q7. If a child overrides a method, can it still call the parent version?

**Answer:**  
Yes.  
Even after overriding, the child can still call the parent version using `super.method()`.

This is the **main reason `super` exists** â€” to allow access to parent behavior even after overriding.

---

## Q8. What happens if you donâ€™t write `super()` explicitly in child constructor?

**Answer:**  
- Java automatically inserts `super()` **only if parent has a default constructor**
- If parent has **only a parameterized constructor**, and child does not call it explicitly:
  ğŸ‘‰ **Compile-time error**

Because Java forces proper initialization of the parent part of the object.

---

## ğŸ”‘ One-Line Interview Summary

`super` is used to access parent class constructor, methods, or variables â€” especially when the child overrides behavior but still needs parent logic.

---
## Q1. If parent reference points to child object

```java
Parent p = new Child();
```
---
Which methods are called at runtime â€” parent or child?
On what basis does Java decide this?

Answer:
Java uses runtime polymorphism for method calls.
The actual object (Child) decides which method runs, not the reference type.

---

## Q2. Which members are decided at compile time and which at runtime?
	â€¢	Methods â†’ runtime (dynamic binding)
	â€¢	Variables â†’ compile time (based on reference type)
---

## Q3. Can variables be overridden like methods in Java? If not, what actually happens?

Answer:
Variables are not overridden.
If parent and child have the same variable name, the variable accessed depends on the reference type, not the object.

```java
class Parent {
    int x = 10;

    void show() {
        System.out.println("Parent show()");
    }
}

class Child extends Parent {
    int x = 20;

    void show() {
        System.out.println("Child show()");
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Child();

        System.out.println(p.x);
        p.show();
    }
}
```

---

## Output.
â†’ 10
â†’Child show()

---

```java
Parent p = new Child();
â†’ Reference type is Parent
â†’ Object created is Child
System.out.println(p.x);
â†’ x is a variable
â†’ Variables are decided at compile time
â†’ Compiler checks reference type (Parent)
â†’ Prints Parent.x â†’ 10
	â€¢	p.show();
â†’ show() is a method
â†’ Methods are decided at runtime
â†’ JVM checks actual object (Child)
â†’ Calls Child.show() â†’ â€œChild show()â€***
```

---

## Q4. Why is Parent p = new Child() heavily used in automation frameworks?

(Framework-design question)

Answer:
Because it allows loose coupling and flexibility.

Real automation reason:
	â€¢	Framework code depends on parent type, not concrete child
	â€¢	Makes it easy to:
	â€¢	switch implementations
	â€¢	reuse code
	â€¢	write generic utilities

	WebDriver driver = new ChromeDriver();
	
	We use WebDriver reference so we can switch browsers (Chrome, Firefox, Edge) without changing test code.

