# ðŸ”’ Encapsulation

---

## Q1. What is Encapsulation in Java? Explain in simple words and relate it to your automation framework.

Encapsulation means protecting data by making variables **private** and exposing them only through **controlled methods** like getters, setters, or page methods.

In my framework, locators are kept private inside Page classes and test classes interact only through page methods, so no one can modify locators directly.

---

***Instance variables are non-static variables declared inside a class but outside methods. They belong to an object
Instance variables cannot be accessed without creating an object because they belong to the object, not the class. They are created when the object is instantiated.***

```java
 class Test {
    int x = 10;

    public static void main(String[] args) {
        System.out.println(x);
    }
}
```
Why does it fail?

Because:
	â€¢	x is an instance variable
	â€¢	main() is a static method
	â€¢	Static methods belong to the class
	â€¢	Instance variables belong to objects

And static methods cannot directly access non-static members

---

***Why is main() static in Java?***
---
The main method is static because it must be invoked by the JVM without creating an object of the class. Since static methods belong to the class, the JVM can call it directly when the program starts.

---

```java
class Test {
    static int x = 5;

    static {
        System.out.println("Static block");
    }

    public static void main(String[] args) {
        System.out.println("Main method");
    }
}
```

---

Class loads â†’ Static block runs â†’ main() runs

Static block
Main method

---
# ðŸ”¹ What actually happens when class loads?
---
***When JVM loads a class:***

> 1ï¸âƒ£ Static variables get default values
> 2ï¸âƒ£ Static variable assignments execute (top to bottom)
> 3ï¸âƒ£ Static blocks execute (top to bottom)
> 4ï¸âƒ£ THEN main() runs

## output
---

```java
class Test {

    static {
        System.out.println("Block");
        show();
    }

    static void show() {
        System.out.println("Method");
    }

    public static void main(String[] args) {
        System.out.println("Main");
    }
}

```
---
Block
Method
Main

---
***Execution Flow***
---

When class loads:

> 1ï¸âƒ£ Static block runs
â†’ prints "Block"
â†’ calls show()

> 2ï¸âƒ£ show() executes
â†’ prints "Method"

> 3ï¸âƒ£ After all static initialization finishes
â†’ main() runs
â†’ prints "Main"
---

```java
class Test {

    static {
        System.out.println("Block");
        show();   // âŒ
    }

    void show() {
        System.out.println("Method");
    }

    public static void main(String[] args) {
        System.out.println("Main");
    }
}
```

---
***ðŸ‘‰ This code will NOT compile at all.***
---

> Because:
>	â€¢	Static block belongs to the class
>	â€¢	show() (non-static) belongs to an object
>	â€¢	At the time static block runs â†’ no object exists

	---


---

## Q2. Why do we keep locators private in Page Object Model?  
### How is this Encapsulation?

We keep locators private in POM so test classes **cannot access or modify them directly**.  
Tests interact only through high-level page methods.

If a locator changes, we update only the **page class instead of all tests** â€”  
that is Encapsulation: hiding data and exposing controlled access.

---

## Q3. â€œEncapsulation is only getters and settersâ€ â€“ True or False?

**False.**

Encapsulation is about:
- protecting data  
- giving controlled access

In my framework:
- locators are private in Page classes  
- tests access them only through methods  
- we are not creating getters and setters  
- but still following Encapsulation.

---

## Q4. Where would you actually use getters & setters in automation?

In real time I used getters and setters for:
- config data  
- test data  
- setting username and password  
- setting browser value

This keeps those values private and accessed in a controlled way.

### Example Code

```java
class User {
    private String username;

    public void setUsername(String u) {
        username = u;
    }

    public String getUsername() {
        return username;
    }
}
```

Explanation:
- `username` is private â†’ direct access blocked  
- `setUsername()` â†’ controlled modification  
- `getUsername()` â†’ controlled reading  

This is classic Encapsulation.

---

## Q5. If a variable is private and we do NOT use getters/setters,  
### how can another class still use that data?

Even without getters/setters, other classes use the data through **page methods**, which act as a controlled interface.

Example:  
Test â†’ calls â†’ `loginPage.login()`  
Not â†’ `loginPage.username`

That is Encapsulation.

---

## Q6. Difference between Abstraction and Encapsulation (Practical)

- **Abstraction** â†’ hiding implementation details and showing only what user needs  
- **Encapsulation** â†’ protecting data and giving controlled access  

Getters/setters are one way to achieve Encapsulation,  
but in POM we often use **page methods** instead.

---

## Q7. How does Encapsulation help in framework maintenance?

Encapsulation helps maintenance because:

- locators and logic stay inside Page classes  
- they are not directly exposed to tests  
- if a locator changes â†’ update only page class  
- test cases remain untouched

This makes the framework **stable and maintainable**.

---

## Q8. What happens if locators are public instead of private?

If locators are public:

- any test can access and modify them directly  
- breaks Encapsulation and POM design  
- increases risk of accidental changes  
- locator updates would require changes in multiple tests

Instead of one page class â†’ huge rework.

---

## Q9. How does Encapsulation reduce impact of locator changes?

Because locators are private inside Page classes:

- tests never use them directly  
- change happens at one place only  
- all tests continue to work

Without Encapsulation:

- same locator would be scattered across tests  
- major maintenance effort.

---

### Final Interview Summary

Encapsulation in Automation =  

> Private data + controlled access through page methods  
> â†’ safer framework  
> â†’ single point change  
> â†’ clean POM design.
---

## Level 3 & Level 4 â€“ Coding + FAANG Tricky

---

## Q10. Write a small code showing Encapsulation

```java
class User {

    private String username;

    public void setUsername(String u) {
        username = u;
    }

    public String getUsername() {
        return username;
    }
}
```

Explanation  
- username is private â†’ direct access not allowed  
- setUsername() â†’ controlled way to modify value  
- getUsername() â†’ controlled way to read value  
This is Encapsulation.

---

## Q11. Why can getUsername() access a private variable?

Getter can access the private variable because private members are accessible within the same class.  
Since the getter method is part of that class, it can read the private variable.

---

## Q12. Can we achieve Encapsulation without getters and setters?

Yes, Encapsulation can be achieved without getters and setters.  
Encapsulation means private data + controlled access through methods.  
In POM, we keep locators private and tests access them through page methods like login() or clickCheckout().  
So even without getters/setters, it is still Encapsulation.

---

## Q13. Is POM more about Abstraction or Encapsulation?

POM supports both Abstraction and Encapsulation.  
It is Abstraction because tests see only high-level actions like login() and donâ€™t see internal Selenium code.  
It is Encapsulation because locators are private and accessed only through page methods.  
But POM is more about Encapsulation, since the main goal is protecting locators and giving controlled access.

---

## Q14. How is Encapsulation related to security in automation framework?

Encapsulation improves security because sensitive data like locators, credentials, or config values are kept private and cannot be accessed directly by tests.  
Access happens only through controlled methods, so no one can accidentally modify internal framework data.  
This prevents misuse of locators and reduces risk of breaking tests due to direct access.
